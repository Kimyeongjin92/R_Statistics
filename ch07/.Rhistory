am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
abline(am1$mpg)
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
am1
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
#  1) mtcars 기어종류 am(오토/수동)에 따른 mpg의 차이가 통계적으로 유의한가.
# H0 수동과 오토의 mpg는 차이가 없다(같다)
# H1 수동과 오토의 mpg는 차이가 있다(다르다)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
knitr::opts_chunk$set(echo = TRUE)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
am1
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg)                  # 정규성을 이룬다.
qqline(am1$mpg)
am0 <- mtcars[mtcars$am == 0,]
shapiro.test(am0$mpg)            # P(0.8987)>0.05
qqnorm(am0$mpg)                  # 정규성을 이룬다.
qqline(am0$mpg)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg) ; qqline(am1$mpg)                 # 정규성을 이룬다.
am0 <- mtcars[mtcars$am == 0,]
shapiro.test(am0$mpg)            # P(0.8987)>0.05
qqnorm(am0$mpg)                  # 정규성을 이룬다.
qqline(am0$mpg)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg) %>% qqline(am1$mpg)                 # 정규성을 이룬다.
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg) + qqline(am1$mpg)                 # 정규성을 이룬다.
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg) ; qqline(am1$mpg)                 # 정규성을 이룬다.
am0 <- mtcars[mtcars$am == 0,]
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)            # P(0.5363)>0.05
qqnorm(am1$mpg) ;qqline(am1$mpg)                 # 정규성을 이룬다.
am0 <- mtcars[mtcars$am == 0,]
shapiro.test(am0$mpg)            # P(0.8987)>0.05
qqnorm(am0$mpg)                  # 정규성을 이룬다.
qqline(am0$mpg)
am1 <- mtcars[mtcars$am == 1,]
shapiro.test(am1$mpg)             # P(0.5363)>0.05
qqnorm(am1$mpg); qqline(am1$mpg)  # 정규성을 이룬다.
mean(am0$mpg) ; sd(am0$mpg)
mean(am1$mpg) ; sd(am1$mpg)
length(am1$mpg)
length(am0$mpg)
length(am0$mpg)
length(am1$mpg)
mean(am0$mpg) ; sd(am0$mpg)
mean(am1$mpg) ; sd(am1$mpg)
# 3) 판정
t.test(mtcars$mpg ~ mtcars$am,   # P(0.000285)<0.05 오토와 수동의 mpg는 다르다(차이가 있다.).
mu = 0,
var.equal=T)
# 1) 정규성 등분산성 검토
USA<-subset(Cars93, Origin=='USA')
non<-subset(Cars93, Origin=='non-USA')
shapiro.test(non$Price) ;qqnorm(non$Price) ;qqline(non$Price) # P(0.0002)<0.05 : 정규성을 이루지 않는다.
var.test(Cars93$Price ~ Cars93$Origin) # P(0.01387)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(Cars93$Price ~ Cars93$Origin,   # P(0.34)>0.05 평균의 차이가 없다.
mu = 0,
var.equal=F)
mean(USA$Origin) ; sd(USA$Origin) ; length(USA$Origin)
mean(non$Origin) ; sd(non$Origin) ; length(non$Origin)
# 1) 정규성 등분산성 검토
USA<-subset(Cars93, Origin=='USA')
shapiro.test(USA$Price) ;qqnorm(USA$Price) ;qqline(USA$Price) # P(0.0002)<0.05 : 정규성을 이루지 않는다.
non<-subset(Cars93, Origin=='non-USA')
shapiro.test(non$Price) ;qqnorm(non$Price) ;qqline(non$Price) # P(0.0002)<0.05 : 정규성을 이루지 않는다.
var.test(Cars93$Price ~ Cars93$Origin) # P(0.01387)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(Cars93$Price ~ Cars93$Origin,   # P(0.34)>0.05 평균의 차이가 없다.
mu = 0,
var.equal=F)
mean(USA$Origin) ; sd(USA$Origin) ; length(USA$Origin)
mean(non$Origin) ; sd(non$Origin) ; length(non$Origin)
mean(USA$Price) ; sd(USA$Price) ; length(USA$Price)
mean(non$Price) ; sd(non$Price) ; length(non$Price)
# 3) 판정
t.test(Cars93$Price ~ Cars93$Origin,   # P(0.34)>0.05 평균의 차이가 없다.
mu = 0,
var.equal=F)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
shapiro.test(subcompact$hwy); qqnorm(subcompact$hwy); qqline(subcompact$hwy) # P(0.01036)<0.05 : 정규성을 이루지 않는다.
midsize    <- subset(mpg, mpg$class=='midsize')
shapiro.test(midsize$hwy); qqnorm(midsize$hwy) ;qqline(midsize$hwy) # P(0.01311)<0.05 :정규성을 이루지 않는다.
var.test(sm$hwy ~ sm$class)  # P(8.825e-08)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
sm<-rbind(subcompact,midsize)
sm<-rbind(subcompact,midsize)
var.test(sm$hwy ~ sm$class)  # P(8.825e-08)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(sm$hwy ~ sm$class,            # P(0.38)>0.05 고속도로 연비의 차이가 없다.
mu = 0,
var.equal=F)
mean(subcompact$hwy) ; sd(subcompact$hwy) ; length(subcompact$hwy)
mean(midsize$hwy) ; sd(midsize$hwy) ; length(midsize$hwy)
# 3) 판정
t.test(rp$cty ~ rp$fl, # P(0.228)>0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
# 1) 정규성 등분산성 검토
r <- subset(mpg, fl=='r')
shapiro.test(r$cty);qqnorm(r$cty) ;qqline(r$cty) # P(2.7e-05)<0.05 :정규성을 이루지 않는다.
p <- subset(mpg, fl=='p')
shapiro.test(p$cty); qqnorm(p$cty);qqline(p$cty) # P(0.498)<0.05 :정규성을 이루지 않으나 근접하다..
rp<-rbind(r,p)
var.test(rp$cty ~ rp$fl) # P(0.0428)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rp$cty ~ rp$fl, # P(0.228)>0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
mean(p$cty) ; sd(p$cty) ; length(p$cty)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
subcompact
str(subcompact)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(2.7e-05)<0.05 :정규성을 이루지 않는다.
r <- subset(mpg, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.498)<0.05 :정규성을 이루지 않으나 근접하다..
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.498)<0.05 :정규성을 이루지 않으나 근접하다..
rf<-rbind(r,f)
var.test(rf$cty ~ rf$fl) # P(0.0428)<0.05 분산이 서로 동일하지 않다.
rp$fl
rp
rp<-rbind(r,p)
rp
var.test(rf$cty ~ rf$drv) # P(0.0428)<0.05 분산이 서로 동일하지 않다.
rp<-rbind(r,p)
var.test(rp$cty ~ rp$fl) # P(0.0428)<0.05 분산이 서로 동일하지 않다.
# 1) 정규성 등분산성 검토
r <- subset(mpg, fl=='r')
shapiro.test(r$cty);qqnorm(r$cty) ;qqline(r$cty) # P(2.7e-05)<0.05 :정규성을 이루지 않는다.
p <- subset(mpg, fl=='p')
shapiro.test(p$cty); qqnorm(p$cty);qqline(p$cty) # P(0.498)<0.05 :정규성을 이루지 않으나 근접하다..
rp<-rbind(r,p)
var.test(rp$cty ~ rp$fl) # P(0.0428)<0.05 분산이 서로 동일하지 않다.
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(0.228)>0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(p$cty) ; sd(p$cty) ; length(p$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(0.228)>0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(p$cty) ; sd(p$cty) ; length(p$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
mean(f$cty) ; sd(f$cty) ; length(f$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(0.228)>0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(f$cty) ; sd(f$cty) ; length(f$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(f$cty) ; sd(f$cty) ; length(f$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
mean(f$cty) ; sd(f$cty) ; length(f$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
str(rf)
table(rf$drv)
table(subcompact$drv)
table(mpg$drv)
table(mpg$drv=='subcompact')
table(mpg$drv)
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
# 1) 정규성 등분산성 검토
subcompact <- subset(mpg, mpg$class=='subcompact')
f <- subset(subcompact, drv=='f')
shapiro.test(f$cty);qqnorm(f$cty) ;qqline(f$cty) # P(0.09599)>0.05 :정규성을 이룬다.
r <- subset(subcompact, drv=='r')
shapiro.test(r$cty); qqnorm(r$cty);qqline(r$cty) # P(0.1048)>0.05 :정규성을 이룬다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
rf<-rbind(r,f)
var.test(rf$cty ~ rf$drv) # P(0.0026)<0.05 분산이 서로 동일하지 않다.
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 없다(같다)
mu = 0,
var.equal=F)
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 있다(다르다)
mu = 0,
var.equal=F)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 있다(다르다)
mu = 0,
var.equal=F)
mean(f$cty) ; sd(f$cty) ; length(f$cty)
mean(r$cty) ; sd(r$cty) ; length(r$cty)
# 3) 판정
t.test(rf$cty ~ rf$drv, # P(1.759e-06)<0.05 도시 연비는 차이가 있다(다르다)
mu = 0,
var.equal=F)
# 1) 정규성 등분산성 검토
am0 <- mtcars[mtcars$am == 0,]
shapiro.test(am0$mpg); qqnorm(am0$mpg); qqline(am0$mpg, col="red")  # P(0.8987)>0.05 : 정규성을 이룬다.
data <- data.frame(sample1 =  c(51.4, 52, 45.5, 54.5, 52.3, 50.9, 52.7, 50.3, 53.8, 53.1),
sample2 = c(50.1, 51.5, 45.9, 53.1, 51.8, 50.3, 52, 49.9, 52.5, 53))
data
View(data)
t.test(data$sample1 ~ data$sample2, paired=T, alternative = "less")
data <- data.frame(sample1 =  c(51.4, 52, 45.5, 54.5, 52.3, 50.9, 52.7, 50.3, 53.8, 53.1),
sample2 = c(50.1, 51.5, 45.9, 53.1, 51.8, 50.3, 52, 49.9, 52.5, 53))
t.test(data$sample1 ~ data$sample2, paired=T, alternative = "less")
# **Paired Sample T-test 연습문제**
## **1번**
#### 새로운 당뇨병 치료제를 개발한 제약사에서는 치료에 지대한 영향을 주는 외부요인을 통제하기 위해 10명의 당뇨병 환자를 선별하여 1달 동안 '위약(placebo)'을 투여한 기간의 혈당 수치(Xi)와 '신약(new medicine)'을 투여한 1달 기간 동안의 혈당 수치(Yi)를 측정하여 짝을 이루어 혈당 차이를 유의수준 5%에서 비교하시오.
```{r}
data <- data.frame(placebo = c(51.4, 52, 45.5, 54.5, 52.3, 50.9, 52.7, 50.3, 53.8, 53.1),
medicine = c(50.1, 51.5, 45.9, 53.1, 51.8, 50.3, 52, 49.9, 52.5, 53))
# Create two polygons: second would be a hole inside the first
xy = cbind(
x = c(13.4, 13.4, 13.6, 13.6, 13.4),
y = c(48.9, 49, 49, 48.9, 48.9)
)
hole.xy <- cbind(
x = c(13.5, 13.5, 13.45, 13.45, 13.5),
y = c(48.98, 48.92, 48.92, 48.98, 48.98)
)
plot(xy)
polygon(xy, density = 20)
polygon(hole.xy, density = 20, angle = -45, col = "blue")
xy.sp <- SpatialPolygons(list(
Polygons(list(Polygon(xy),
Polygon(hole.xy, hole = TRUE)), "1"),
Polygons(list(Polygon(xy + 0.2),
Polygon(xy + 0.35),
Polygon(hole.xy + 0.2, hole = TRUE)), "2")
))
library(HatchedPolygons)
library(dplyr)
library(sp)
library(sf)
library(raster)
library(HatchedPolygons)
library(HatchedPolygons)
install.packages("HatchedPolygons")
library(HatchedPolygons)
install.packages("HatchedPolygons")
plot(xy)
polygon(xy, density = 20)
polygon(hole.xy, density = 20, angle = -45, col = "blue")
xy.sp <- SpatialPolygons(list(
Polygons(list(Polygon(xy),
Polygon(hole.xy, hole = TRUE)), "1"),
Polygons(list(Polygon(xy + 0.2),
Polygon(xy + 0.35),
Polygon(hole.xy + 0.2, hole = TRUE)), "2")
))
library(ggplot2)
xy.sp.hatch.sf <- sf::st_as_sf(xy.sp.hatch)
xy.sp.sf <- sf::st_as_sf(xy.sp) %>%
mutate(ID = factor(1:2))
ggplot() +
geom_sf(data = xy.sp.sf, aes(fill = ID)) +
geom_sf(data = xy.sp.hatch.sf, aes(colour = ID)) +
scale_colour_manual(values = c("#6BA5F7", "#545454"))
data <- data.frame(placebo = c(51.4, 52, 45.5, 54.5, 52.3, 50.9, 52.7, 50.3, 53.8, 53.1),
medicine = c(50.1, 51.5, 45.9, 53.1, 51.8, 50.3, 52, 49.9, 52.5, 53))
t.test(data$placebo, data$medicine, paired=T, alternative = "greater",conf.level=0.95)
hf <- read.table("http://www.randomservices.org/random/data/Galton.txt",
header=T, stringsAsFactors = F)
str(hf)
hf$Gender <- factor(hf$Gender, levels=c('M','F'))
hf.son    <- subset(hf,Gender=='M')
hf$Gender <- factor(hf$Gender, levels=c('M','F'))
hf.son    <- subset(hf,Gender=='M')
hf.son    <- hf.son[c("Father","Height")),]
hf.son    <- hf.son[c("Father","Height")]
f.mean    <- mean(hf.son$Father)
s.mean    <- mean(hf.son$Height)
cov.num   <- sum((hf.son$Father-f.mean)*(hf.son$Height-s.mean))
cov.xy    <- cov.num / (nrow(hf.son)-1)
cov(hf.son$Father, hf.son$Height)
r.xy      <- cov.xy / (sd(hf.son$Father)* sd(hf.son$Height))
# R 함수를 이용한 상관계수
cor(hf.son$Father, hf.son$Height)
# 상관계수를 구하기 위해 표준편차로 나눈다.
r.xy      <- cov.xy / (sd(hf.son$Father)* sd(hf.son$Height))
r.xy
plot(hf)
plot(hf.son)
plot(t(hf.son)
plot(t(hf.son))
# 그래프
plot(hf.son$Father,hf.son$Height)
# 그래프
plot(hf.son$Height,hf.son$Father)
# 회귀계수의 추정
mean.x <- mean(hf.son$Father)
mean.y <- mean(hf.son$Height)
sxy    <- sum((hf.son$Father - mean.x)*(hf.son$Height - mean.y))
sxx    <- sum((hf.son$Father - mena.x)^2)
b1     <- sxy / sxx
b0p    <- mean.y - b1 * mean.x
# 회귀계수의 추정
mean.x <- mean(hf.son$Father)
mean.y <- mean(hf.son$Height)
sxy    <- sum((hf.son$Father - mean.x)*(hf.son$Height - mean.y))
sxx    <- sum((hf.son$Father - mena.x)^2)
sxy    <- sum((hf.son$Father - mean.x)*(hf.son$Height - mean.y))
sxx    <- sum((hf.son$Father - mean.x)^2)
b1     <- sxy / sxx
b0p    <- mean.y - b1 * mean.x
b1     <- sxy / sxx
b0p    <- mean.y - b1 * mean.x
b0     <- mean.y - b1 * mean.x
# lm() 함수 이용
out    <- lm(Height ~ Father, data=hf.son)
summary(out)
plot(out)
plot(out)
out    <- lm(Height ~ Father, data=hf.son)
summary(out) # *** 굉장히 유의하다. 둘다 전부 유의하다.
par(mfrow=c(2,2))
plot(out)
women
plot(women$height, women$weight)
plot(women$weight,women$height)
plot(women$height,women$weight)
plot(fit)
fit <- lm(weight~height)
fit <- lm(weight~height, data=women)
abline(fit,col="red",lwd=2)
summary(fit)
cor.test(women$weight, women$height)
par(mfrow=c(2,2))
#
cor.test(women$weight, women$height)
plot(fit)
fit2 <- lm(weight~height + I(height^2), data=women) # 독립변수 여러개 나열
fit  <- lm(weight~height, data=women)
fit2 <- lm(weight~height + I(height^2), data=women) # 독립변수 여러개 나열
plot(women$height,women$weight)
plot(women$height,women$weight)
fit2 <- lm(weight~height + I(height^2), data=women) # 독립변수 여러개 나열
lines(women$height, fitted(fit2), col="green",lwd=2)
abline(fit,col="red",lwd=2)
summary(fit2)
par(mfrow=c(2,2))
plot(fit2)
# 3차식
fit3 <- lm(weight~height + I(height^2) + I(height^2), data=women) # 독립변수 추가
# 3차식
fit3 <- lm(weight~height + I(height^2) + I(height^2), data=women) # 독립변수 추가
plot(women$height,women$weight)
lines(women$height, fitted(fit3), col="orange",lwd=2)
# 3차식
fit3 <- lm(weight~height + I(height^2) + I(height^2), data=women) # 독립변수 추가
plot(women$height,women$weight)
lines(women$height, fitted(fit3), col="orange",lwd=2)
summary(fit3)
# 3차식
fit3 <- lm(weight~height + I(height^2) + I(height^2), data=women) # 독립변수 추가
plot(women$height,women$weight)
lines(women$height, fitted(fit3), col="orange",lwd=2)
summary(fit3)
# 3차식
fit3 <- lm(weight~height + I(height^2) + I(height^3), data=women) # 독립변수 추가
plot(women$height,women$weight)
lines(women$height, fitted(fit3), col="orange",lwd=2)
summary(fit3)
# 3차식 ---------------------------------------------------------------
fit3 <- lm(weight~height + I(height^2) + I(height^3), data=women) # 독립변수 추가
plot(women$height,women$weight)
lines(women$height, fitted(fit3), col="orange",lwd=2)
summary(fit3)
par(mfrow=c(2,2))
plot(fit3)
AIC(fit2)
AIC(fit3)
state.x77
states <- as.data.frame(state.x77[,c("Murder","Population",
"Illiteracy","Income","Frost")])
# 살인사건에 대한 독립변수가 될 만한 것을 골라서 회귀분석을 해보자.
fit <- lm(Murder ~ Population+Illiteracy+Income+Frost, data=states)
summary(fit)
par(mfrow=c(2,2))
plot(fit)
par(mfrow=c(1,1))
fit1 <- lm(Murder ~ .,data=states) # 점(.) : 나머지 변수 전부.
summary(fit1)
fit1 <- lm(Murder ~ .,data=states) # 점(.) : 나머지 변수 전부.
summary(fit1)
# 필요없어보이는 것을 제외하고 다시
fit2 <- lm(Murder ~ Population + Illiteracy, data=states)
summary(fit2)
# AIC(Akaike Information Criterion) : 값이 적을수록 좋은 모델
AIC(fit1, fit2)
